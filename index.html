
<!DOCTYPE HTML>
<html>
<head>
	<meta charset="utf-8">
	<title>YYLFC</title>
	<meta name="author" content="Yan Yu">

	
	<meta name="description" content="2013年12月至今，我一直工作在海外交付项目上，经历了大大小小十多个项目，由于公司和我所在项目的客户都很推崇敏捷实践，所以对项目上的敏捷实践也有一点自己的看法。敏捷提倡快速响应变化，所以敏捷实践不是一成不变的，而且敏捷理论也不是在所有的项目中都适用，它需要根据项目的实际情况进行相应调整， &hellip;">
	
	<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">

	<link href="/atom.xml" rel="alternate" title="YYLFC" type="application/atom+xml">
	<link rel="canonical" href="">
	<link href="/favicon.png" rel="shortcut icon">
	<link href="/stylesheets/screen.css" media="screen, projection" rel="stylesheet" type="text/css">
	<!--[if lt IE 9]><script src="//html5shiv.googlecode.com/svn/trunk/html5.js"></script><![endif]-->
	<script async="true" src="//ajax.googleapis.com/ajax/libs/jquery/1.7.2/jquery.min.js"></script>
	
</head>


<body>
	<header id="header" class="inner"><h1><a href="/">YYLFC</a></h1>
<nav id="main-nav"><ul class="main">
	<li><a href="/">Blog</a></li>
	<li><a href="/blog/archives">Archives</a></li>
	<li><a href="/about">About</a></li>
</ul>
</nav>
<nav id="mobile-nav">
	<div class="alignleft menu">
		<a class="button">Menu</a>
		<div class="container"><ul class="main">
	<li><a href="/">Blog</a></li>
	<li><a href="/blog/archives">Archives</a></li>
	<li><a href="/about">About</a></li>
</ul>
</div>
	</div>
	<div class="alignright search">
		<a class="button"></a>
		<div class="container">
			<form action="https://www.google.com/search" method="get">
				<input type="text" name="q" results="0">
				<input type="hidden" name="q" value="site:yanyujason.github.io">
			</form>
		</div>
	</div>
</nav>
<nav id="sub-nav" class="alignright">
	<div class="social">
		
		
		
		
		<a class="github" href="https://github.com/yanyujason" title="GitHub">GitHub</a>
		
    
		
		
		
		
		
		<a class="rss" href="/atom.xml" title="RSS">RSS</a>
		
    
	</div>
	<form class="search" action="https://www.google.com/search" method="get">
		<input class="alignright" type="text" name="q" results="0">
		<input type="hidden" name="q" value="site:yanyujason.github.io">
	</form>
</nav>

</header>
	
		
	
	<div id="content" class="inner">


    <article class="post">
	<h2 class="title">
		
		<a href="/blog/2017/03/07/offshorexiang-mu-yu-shang-deadline/">
		
			Offshore项目遇上Deadline</a>
	</h2>
	<div class="entry-content">
		<p>  2013年12月至今，我一直工作在海外交付项目上，经历了大大小小十多个项目，由于公司和我所在项目的客户都很推崇敏捷实践，所以对项目上的敏捷实践也有一点自己的看法。敏捷提倡快速响应变化，所以敏捷实践不是一成不变的，而且敏捷理论也不是在所有的项目中都适用，它需要根据项目的实际情况进行相应调整，这就需要团队在项目过程中积极识别项目的风险和问题、评估这些风险和问题，最终找到解决的方法。这篇文章就是我自己对近期的一个项目上的实践进行的总结，以及在项目中遇到的具体问题的一些解决方法。</p>

<h2>项目背景</h2>

<p>项目主要是为澳洲某建筑开发商构建一个展示自身信息的网站，主要包括了开发商公司信息、品牌、房屋设计信息、样板间信息以及社交联系方式等，整个项目一共分为两个阶段：</p>

<ul>
<li><p>第一阶段是构建一个响应式的前端页面用于展示开发商的所有信息，并且只为6个测试开发商上线，用于产品的快速验证和反馈，所以所有数据以JSON格式存放于AWS的S3上，没有后台数据API，前端页面直接消费这6个JSON文件。简单来说就是从JSON读数据并在前端渲染页面。</p></li>
<li><p>第二阶段是构建一个管理页面，用于对所有目标开发商提供信息录入功能，并将所有信息存入数据库并生成第一阶段所需要的JSON文件，放入S3。简单来说就是构建一个信息录入页面并保存至数据库和S3。</p></li>
</ul>


<p>项目第一阶段的前端页面成功上线，反馈良好，所以项目第二阶段如期开始。为了更好地实现第二阶段的项目需求，在第一阶段项目结束后，整个项目组（包含客户）进行了一次项目的<a href="https://en.wikipedia.org/wiki/Retrospective#Software_development">retrospective</a>，用于发现项目第一阶段实践中的问题并解决，避免第二阶段重复犯错。一些问题被挖掘出来，比如每个<a href="https://en.wikipedia.org/wiki/Scrum_(software_development">迭代</a>)的计划做的不好、每个故事卡的预估(Estimation)做的不好、故事卡每个阶段的状态以及从开始开发到上线的时长没有追踪、代码实现完成后与QA的交接没有做好（比如很难同时找到BA、QA以及UX一起做），大家也积极讨论解决方案，最终产出了一些行动。并且在第二阶段的项目启动中，全组成员一起了解需求，拆分epic，对每张故事卡做了预估，最后提出了解决方案和完成架构的设计。这套架构方案很好的解决了项目需求：</p>

<ul>
<li><p>采用前后端分离，前端使用React和Redux，因为录入信息都是通过页面表单形式，所以也引入了Redux-form，前端只获取数据渲染页面；后端使用Rails-api，提供数据在Postgres数据库中的增删改查；在前后端之间又加入了一层Backend-for-Frontend（并不是传统意义上的BFF），目的是用于前端请求的转发，用户访问权限的校验，以及与第三方服务（比如Image server）的集成等。</p></li>
<li><p>数据录入数据库后，使用AWS的Kinesis和Lambda服务将开发商所有录入信息生成的JSON文件导入S3供第一阶段的前端页面使用。</p></li>
</ul>


<p>这是一个看起来很不错的设计，当然，也可以直接选择一套更为直接的Ruby on Rails解决所有问题。作为一个稍微有点节操的码农自然不会选择ROR那样子的设计，原因不详述。根据这个设计，我们也作出了估计：现有人员配置为2名产品经理，1名交付经理，1名业务分析师，1名测试人员，1名Ops和7名开发（除了其中4名开发外，其余都是客户团队，并且业务分析师能力不足），项目7月中旬开始，大约需要4个月时间到11月中旬完成第一个里程碑（Milestone）的所有需求。2名产品经理也很认可，项目如期开始了。</p>

<p>这套系统看似简单，实际很复杂，有新代码库的构建，有跟其他3个已有系统的集成，也有一些AWS服务的使用。再细节一点，前端代码JS、CSS的打包，前端任务的构建等，一共花费了5名开发人员和1名Ops人员1个迭代（2周）左右的时间完成了三个代码库、CI Pipeline以及AWS相关服务的构建。也就是说在8月初的时候才开始实现产品功能。8月中旬的一天，DL突然给整个团队一个惊喜，那就是由于业务和销售方面的原因，原定于11月中旬的发布需要提前至10月3日，掐指一算，提前了4个迭代（8周）。项目突然有了deadline！</p>

<p>对于这个晴天霹雳，作为一个拥有4名成员的专业的服务性团队，我们依据关于开销（Cost）、时间（Time）和产品范围（Scope）的三角形原则（见图一)，给出了最常见的应对方案，增加开销（增加开发人员）和减小产品功能范围。</p>

<div style="text-align:center" markdown="1">
<img src="/images/blogs/quality-triangle.png" width = "350" height = "350" />
<p>图一：质量三角形原则</p>
</div>


<p>增加开发人员就不细说了，项目只要有预算，可以尽可能多的加人，唯一要考虑的是加什么样的人。往往这种短期的加人对人的要求更高，需要快速了解业务，快速上手代码，不然加人只会拖慢项目进度，因为<a href="https://en.wikipedia.org/wiki/Pair_programming">结对编程</a>时需要更多的进行业务的讲解和技术基础知识的培训，这是不合适的。下面主要说说减少产品功能的问题。</p>

<h2>Deadline下的<a href="https://www.techopedia.com/definition/27809/minimum-viable-product-mvp">MVP</a></h2>

<p>对于突然设置的Deadline，团队果断采用MVP(Minimum Viable Product)的思想来应对，下面来谈一谈我们项目在Deadline压力下使用MVP思想时遇到的问题和一些项目实践，以及自己的看法。</p>

<h3>故事卡优先级</h3>

<p>在项目对交付时间有压力时，就要对项目的需求进行重新评估。在我们项目中，无论是产品经理还是我们开发人员本身都参与了很多关于需求梳理方面的工作。</p>

<p>第一项就是排优先级，产品经理、业务分析师和用户体验设计师会将所有必须上线的功能从现有的故事墙上（项目启动时，epic的划分和epic中的需求大部分已经明确，所以项目开始就建好了所有的故事卡）挪出，排好业务上的优先级，然后将所有排好的故事卡给所有开发人员和测试人员，开发和测试人员一起对每一个故事卡进行估点，然后再由产品经理根据业务优先级和技术难度和工作量决定哪些需求要做，哪些需求先做，哪些需求可以去掉。具体的策略如下图：</p>

<div style="text-align:center" markdown="1">
<img src="/images/blogs/estimation-value.png" width = "350" height = "350" />
<p>图二：优先级</p>
</div>


<p>先做高业务优先级并且低开发成本的故事卡，再做高业务高开发成本的故事卡，接着是低业务低开发成本的故事卡，最后舍弃掉低业务高开发成本的功能。最终业务分析师和交付经理会根据项目组的工作速率(Velocity)给出发布前的迭代的计划。</p>

<h3>功能优先</h3>

<p>功能优先，顾名思义，就是说优先实现所需要的功能，用户的体验在一些特定条件下可以削弱，比如，内部系统的UI层的用户体验可以不必像给真实用户的那么完美。举个例子：</p>

<blockquote><p>在项目中，给真实用户的前端页面会在谷歌地图上显示不同样板间的地理位置信息，所以管理人员在后台信息录入时需要在谷歌地图上自定义样板间的位置，然而这个在地图上拖拽的需求在业务上（至少是在上项目的第一个milestone发布前）没那么重要，转而采用的是经纬度的录入。这样，前端仍然可以给真实用户显示合适的位置，但是开发人员在开发时的时间会减少很多。</p></blockquote>

<p>在milestone 1中，页面的样式也不需要很完美，我们只需要给内部管理用户提供一个功能健全的表格供他们录入信息，至于一些提升用户体验的功能，比如系统发生错误时的提示消息的样式、区分页面不同组件的背景色的样式等，都可以省去不做。当然，也不是说一点样式没有，如果没有样式，网站的可用性会大打折扣，比如：表格字段验证失败的错误信息提示还是会显示在校验失败字段的上方，只是没有提示的文字没有背景色，同时也没有将输入框高亮起来。</p>

<p>但是，功能优先的一个负面影响是对于那些解决方案不明确的功能卡，没有时间专门去创建spike卡来研究解决方案并且追踪。</p>

<blockquote><p>Spike卡：当完成一些需求是有一定的技术问题，或者解决方案尚不明确，又或者对所需要的第三方服务不了解时，通常会创建一张Spike卡用于研究调查并解决这些技术问题、了解所有依赖的第三方服务用法，并且提出一个合理的解决方案。不需要完成对功能的实现代码，只需要输出解决方案即可。</p></blockquote>

<p>所以当遇到这些有技术问题的故事卡时，在估点时基于解决方案已经清楚的原则，估出来的点数往往小于实际的点数。当然，也可以将Spike的点数直接估计在故事卡中，往往这样做会使故事卡的点数太大，影响准确性。所以在开发这些故事卡时，我们不得不给Spike一个很短的时间限定，当有多种解决方案的时候，可能直接会选择简单或者耗时短的那一种，并没有太多考虑将来的复用性或者功能的可扩展性。在将来，这种解决方案很可能不能很好地支持所需要的新功能。而且Spike的时间越短，对代码设计或者方案本身的评估来说也会越不准确，很可能因为Spike不足，引入其他问题。比如选定的一种React组件不能满足新需求新功能的时候，就会需要花费更多的时间去重新实现已有功能，再开始实现新功能。而选择功能优先确实也为我们在Milestone 2带来了一定的时间浪费。</p>

<h3>速度优先</h3>

<p>对于开发人员，尤其是在项目交付时间压力比较大的团队里，如何平衡交付速度和技术追求成了一个很难解决的问题。项目工作量很多，开发人员需要保证项目及时交付。但对于开发人员本身，又需要对代码质量和代码追求有最基本的底线和节操。</p>

<p>在项目过程中的一次Retrospective里，客户PM和DL明确指出项目“Speed first，code quality second”。又由于开发人员自身原因，比如作为v软件的供应商(Vendor)，心里难免有Vendor心态，就是客户提出来的要求都需要尽量满足，客户说什么就是什么，那就先交付吧，其实并没有按照合作方或者作为一支专业的技术服务团队应有的态度去跟客户分析速度优先带来的问题。</p>

<p>在deadline的压力下，项目经理和交付经理也有来自其他部门的压力，比如来自销售团队和更高一级领导的压力，所以经常在<a href="https://en.wikipedia.org/wiki/Stand-up_meeting">站会</a>上或者项目迭代计划会议上听到交付经理会问所有人：“我们还有30天，还剩31个故事卡，可以做完吗？”“这个迭代有15张卡，你们做的完吧？”之类的问题。无形之中给团队带来很大精神层面的压力。</p>

<p>一味的追求速度，会使开发人员，尤其是团队里面的新人养成很不好的开发习惯，比如：</p>

<blockquote><p>1.对故事卡不做Kickoff。在交付压力下，开发人员潜移默化地选择尽可能快的拿故事卡做故事卡，并没有与相关人员一起进行故事卡的Kickoff，所以在做卡过程中加入了开发人员自己对功能的理解，而这些理解并不是产品经理真正想要的需求。这会导致故事卡的复工。</p>

<p>2.不做Showcase。因为找齐业务分析师、测试人员和用户体验设计师对故事卡进行展示(Showcase)比较难，或者觉得大家都理解功能是什么、这张故事卡要做什么，没必要找齐他们做showcase。带来的后果是一些Bug没有第一时间被发现，导致该功能不能上线，需要打回继续开发。但是开发这张卡的开发人员又开始了新的故事卡，边做新卡边修Bug，需要在不同的卡上来回切换，影响开发效率和质量。</p></blockquote>

<p>在速度优先的思想下，团队遇到了一些问题，也根据团队自己的理解提出了一些改进：</p>

<h4>故事卡过大</h4>

<p>由于业务分析师技能的缺失，导致很多故事卡过大，功能点过多。这会带来一下两方面影响：</p>

<ul>
<li><p><strong>Bug数增加</strong> 因为开发人员需要考虑每一个需求的每一种情况，所以需求多了，所要考虑的点也就越多，难免会漏掉一些，增加了Bug数。</p></li>
<li><p><strong>估点不准确</strong> 如果估点少了，开发人员在开发时候的压力会很大。因为有时候开发人员对点数的理解可能有误，觉得每一个点可能就是一天。比如：一张卡估了5个点，当做到第3天的时候，发现还有几个需求没有实现，这样会给开发带来很大压力，对需求考虑的完整性也会大大下降，进而导致更多的复工和bug。</p></li>
</ul>


<p>故事卡太大怎么办？很明显就会想到——拆卡。像业务分析师提出拆卡需求时，一般提倡拿出拆卡的理由并给出如何拆卡的建议，尤其是与技术相关时。在我们项目中，尝试过两种拆卡方式：</p>

<ul>
<li><p><strong>前后端分离拆卡</strong> 将一个故事卡的前端和后端工作分开，前端一张卡，后端一张卡。比如：</p>

<blockquote><p>项目需要录入开发商的每一个设计的信息，表单内容非常多，而且每个信息都有一些校验。前端的卡包括渲染表单页面，发送获取现有信息、存储新信息的请求，以及页面基本的样式；后端的卡包括完成信息增删改查的API和存储校验。</p></blockquote>

<p>这样做的好处是人员可以充分利用，前端能力强的人专注前端，后端能力强的人专注后端，各取所长，提升交付速度。缺点在于提升了沟通和测试成本，前后端的故事卡需要提前沟通好数据格式。如果前期没有考虑周全，在开发过程中一点点数据格式的变动可能会引起很大的修改。而且有时候前后端分开后的两张卡不是同时做，一对Pair定义好的数据格式由于缺少沟通，需要花费下一对Pair一定时间去查看（当然可以有些协议测试来保证，但是项目中并没有引入）。在前后端做完后，需要有一张独立的卡开做集成，比较耗时。</p>

<p>对于测试来说，单纯的后端的卡只能通过一些工具（比如Postman）来测试；前端的卡，只能通过浏览器工具看看数据是不是真的发到了后台；对于集成的卡，又需要再将前后端集成测试一遍，也很耗时。对于功能交付来说，我们一般都需要保证每一个故事卡传递一定的用户价值。这么做对于没有集成的独立的前端或者后端的卡，只是隐形的交付了一些价值。在集成卡没有上线时，产品经理因为功能不可用，所以不认为这是交付物。所以：</p>

<blockquote><p>我认为这种拆卡方式只适合于产品定期发布，也就是完成了很多功能后一次上线。并不适合持续发布，因为对于前后端分离的系统，只有前端展示页面而没有后台逻辑处理就发布到产品环境是很搞笑的。</p></blockquote></li>
<li><p><strong>按功能点拆卡</strong> 与前后端拆卡不同，这样拆卡可以保证每一个子卡在做完后都是一个可以交付的产物。举例说明：</p>

<blockquote><ul>
<li><p>刚才那个例子，对于开发商的设计信息的录入，可以拆成上传设计图片，填写设计基本信息，以及添加不同的设计的数据校验</p></li>
<li><p>在做对于房屋设计的筛选功能时，可以拆成按照面积过滤、按照层数过滤，按照卧室数量过滤等。</p></li>
</ul>
</blockquote>

<p>按照功能点拆卡后，每一张子卡都可以在做完后独立发布。这样做的缺点是有时候一些相似的功能点在并行开发时，会产生一些重复代码。比如我们项目前端用的是React，在面积过滤和卧室数量过滤时的两个组件是可以复用的。如果一起开发，不同的开发人员可能会写出不同的组件，需要在后面花时间重构，这会增加开发时间。另一个问题是如果拆分的不合理，会使卡产生依赖，就是说A卡必须在B卡结束后才能开始开发。但是如果合理做卡的计划，这个问题就不是一个大问题。</p>

<blockquote><p>我认为这种拆卡方式比较适合产品已经上线，但是仍然需要增加新功能的时候使用。可以做到持续发布。</p></blockquote></li>
</ul>


<p>项目上因为故事卡太大，走过很多弯路，也浪费了很多开发和沟通时间，但是慢慢通过自己的拆卡，达到了一个让所有人都接受的程度。解决这个问题我的看法是：</p>

<blockquote><p>当通过拆卡保证这些大的故事卡不会成为影响交付速度和交付质量的阻碍时，就算做的不错！</p></blockquote>

<h4>需求频繁变更与估点</h4>

<p>这是一个大家都熟悉的话题，我想所有接触敏捷的人都已经理解了估点的意义和做法。但是我想要说的是敏捷里的估点的概念有时候在外部条件影响下，可能并不能够被完美执行。最主要的问题是——耗时。</p>

<p>7个开发，4-5对的Pair，对一个自身技能并不出色的业务分析师来说，是很大挑战，所以经常会发现故事卡的需求很不明确，故事卡需求的划分也很不明确。如果按部就班的做估点，那么对需求就会有很多假设。基于这些假设做出来的估点最大的缺陷就是当需求明确时，并且实际需求跟当时的假设不完全匹配，估点这项工作肯定是需要重新做的。又需要召集所有开发和测试，重新花时间做估点。</p>

<p>所以我们决定改变传统意义上的估点，我们加入了自信心级别。在对每一个卡进行了技术估点之后，我们又加入了对这个卡的信心估点，也就是说每个人要根据自己的技术能力和对需求的理解程度对每一个卡加入自己的信心估值。比如：</p>

<blockquote><p>如果这张卡给我做，我十分确认技术解决方案？还是我只知道可能的方案？或者我没有相关的经验？甚至是我完全不理解需求？</p></blockquote>

<p>每个卡也只花费很短的时间。这带来的好处是帮助了交付经理更好地做项目计划，而且在做卡的时候，根据这个自信心估值，可以提早的进行讨论或者寻求帮助，对进度有促进左右。在计算项目总点数时，我们对于每一张故事卡采用<code>实际点数 = 故事点数 * 自信心估值</code>的算法进行计算。</p>

<p>对于频繁的需求变更，我们的实践是：</p>

<ul>
<li><p>在开发之前的变更，只需要更新故事卡就好。</p></li>
<li><p>在开发过程中的需求变更（在我们项目中经常发生，因为有些需求真的是开发在做的过程中驱动出来的），开发人员需要及时改正，因为如果按照原来的需求做完，项目经理又想要新的需求，可能做之前需求的时间就浪费了。</p></li>
<li><p>在测试时候或者在项目经理复查时候的需求变更，我们会重新建新卡完成，而不是打回给开发继续开发。这是其他项目的标准做法，但是在我们项目中实践的并不好，起初任何需求变更都会放在同一张卡中，反复去做（我经历过3次需求A变更到B再变更回A的过程）。这样做会导致整个故事卡在开发过程中的时间很长，而且很影响故事卡的周期时间(Cycle time)。间接的影响是PM觉得我们这么一个功能做了很长时间，因为PM不会了解所有卡的实现细节，也不会记得每一张卡的需求变更，结果导向来看，确实花了很长时间，而且有些迭代真的只交付了很少卡。</p></li>
</ul>


<p>采用之前提到的三种方法，可以保证卡按照正常流程交付，避免了开发人员被项目经理的误解，也会增加项目经理对开发人员的信心。</p>

<h4>技术债（Tech Debt）卡</h4>

<p>在日常完成故事卡过程中，当发现有任何技术改进点，如果代码改动比较大，耗时比较长，我们会写成一个名为Tech Debt的卡，在项目交付后再做。在创建这些卡后，会给出估点，也会给出做了这个改动，带来的影响是什么，比如会提升代码可读性，节约今后的维护或者扩展成本，还是只是单纯为了代码炫酷。每一张卡都会平衡这些影响。举个例子：</p>

<blockquote><p>Redux-form从Version 5到6的升级: 这个升级需要很大改动，它可以保证新的Redux-form的代码更加可读，也修复了一些本身功能性的不足，但是这一次的修改会引起很大的修改，因为一些组件或者整个表单的字段的用法有很大改变，所以需要整体性的评估再决定要不要做。</p></blockquote>

<p>这些“技术债”肯定对当前或者将来有影响，但是要不要还，什么时间还，需要评估来决定。</p>

<h4>Dev huddle</h4>

<p>这是一个被全组都认可的实践。</p>

<p>每天项目所有人会有站会，用于更新每张卡的进度，这更关注与业务方面的更新，由于时间原因，又不能太深的讨论技术细节，所以对于所有的开发人员和测试人我们自己的决定每天开一个关于技术的站会，用来专门讨论当前每对Pair开发的故事卡的解决方案或者遇到的问题，也可以更新自己为项目中引入了什么新的技术，比如一些ruby Gem之类的，我们称这个活动为“Dev huddle”。</p>

<p>起初，我并不认可这个活动，因为让所有开发人员（项目组有7名开发）每天在一起半个小时讨论每个卡是怎么做的本身的成本就很大，而且给我在心里的感觉是我很平常的故事卡的解决方案都需要在其他5名开发的“审阅”之后才可以继续做。这让我的心里存在极大的信任问题。但是经过一段时间后，我改变了这种看法。在Dev huddle上，我们讨论了如何设计API，如何设计数据库结构，如何正确使用Redux-form和一些具体问题的解决方案，有时候也会展示一下未完成的代码，这样的好处有：</p>

<ul>
<li><p>让所有人都对我们的代码库有了很深的了解，知道每个人都在做什么、是怎么做的，所以在做新故事卡的时候可以完全按照优先级来拿卡，不用太考虑我在这个代码库或者我对这个方面的代码逻辑不熟悉。这无形中其实减少了一些卡的阻碍，潜在地提升了速度。</p></li>
<li><p>每个故事卡的解决方案都是被全组认可的，每个人都可以发表自己的意见，可以把自己在某方面的知识分享给大家，这保证了大家都在高交付压力下也能学到东西并且交付质量也是过关的。</p></li>
</ul>


<h4>测试驱动开发（TDD）？</h4>

<p>关于要不要TDD，在项目过程中争议很大。后台API端的TDD还好说，可以比较清楚也比较简单的进行TDD。可是对于前端React组件的测试，由于一些原因（比如开发自身能力不足，对React的单元测试不熟悉），测试的力度如何，什么要测，什么不测，这些都是阻碍前端TDD的障碍。而且，就TDD本身来说，因为每个人对TDD的理解深入程度不同，熟练程度不同，认可度不同，所以强制要求TDD或者短期内深入了解TDD，尤其是前端，在短期有Deadline的项目里看起来并不是很适合。所以，我们达成一致：</p>

<blockquote><p>前端可以先写实现再加入测试，但是要保证测试覆盖率达到标准。</p></blockquote>

<h3>管理客户期望</h3>

<p>管理客户期望？在我看来，客户都是贪婪的，如果你的团队在一个迭代能完成20个点，客户在一个迭代中排了比20个点稍微多一点的stories，比如23个点，这时，团队看了这23个点，觉得必须给客户完成，所以采用一些“未告知客户”的加班，或者放弃一些好的代码实践，或者放弃了一些公司的session学习等，最终完成了23个点，这时团队暴露的velocity会因为工作时间加长而增加，这时“贪婪的”客户势必会给每个迭代排更多的点，更多的卡，而一次次团队做出“牺牲”最终都达到了客户“贪婪的”期望，客户会更加“贪婪”，直到团队达到极限。这对于团队来说是很危险的，尤其是像我们这种客户很不善鼓励的团队而言。在项目进行到中期，大概9月份的样子，因为整个团队都很压抑，似乎每一个迭代都完成了客户“贪婪的”期望后，还是在被反复询问“我们在10月3号之前可以做完吗？这个迭代plan的卡可以做完吗？”诸如此类很不专业的问题。事实上这个问题对于开发很难回答，尤其是连自己velocity和迭代estimation做的很不好的团队，大家都选择沉默（这是不好的），所以客户会觉得你们不提反对意见，那么就是可以完成了。组里中间有一个其他组过来帮忙的开发人员在工作了两周后，发表感慨：“你们每天工作时间好长，感觉早上下午只有一次站起来去喝水的机会。”这是也不是一个好的实践。所以，如何管理客户期望，成了主要问题。当时有个其他的同事给我们建议：“下一次客户再plan太多story点或者个数的时候，你们故意不要完成，这样团队压力就不会太大了。”我们觉得这并不是一个从根本解决问题的方案。于是我们团队做了内部retro，发现最主要的问题还是estimation和velocity计算方式的问题。之前我们给每一张卡的估点采用T-shirt size的方式，只有S，M和L三种，DL计算velocity的方式更是采用了数story个数的方式。然而组内BA的能力并没有达到可以把每一个story拆的一样大小。这样就导致客户DL对团队velocity理解有着很大的偏差，所以在做plan的时候也不准确。我们团队在尝试3、4次给客户DL提出要用fibonacci数列方式估点，用点数计算velocity后，客户终于同意，并且在每个迭代里面只plan跟velocity相同点数的story。前面两次我们都只是提出了我们应该怎么做，这么做的好处是什么这样的理论，但是并没有将真实的数据反应给客户，比如我们自己并没有采用fibonacci数列真正给每个story，直到我们自身实践，客户也真的看到了这样做的好处，所以最后一次他也做出了改变。其实在这里，我并不是想说如何以正确的方式去做estimation和计算velocity，我想强调的是在给客户提出任何建议的时候，最好有数据支持，并且需要从自身团队做起，把好的实践应用到项目里，通过这些时间潜移默化的促进项目进展，也慢慢的影响客户的工作方式，这才是应该做的，而不是整天抱怨项目压力大，客户难搞。</p>

<h2>小结</h2>

<p>这些就是我们项目上遇到的一些问题和我们为了解决这些问题的一些实践。总结一下就是，项目进行过程中，一些有悖于敏捷实践best practice的问题肯定都会存在，我们要做的并不是将敏捷那些最基本的流程和概念强行加入到自己的项目中，我们所要做的是将那些好的理论转化成为最适合自己项目的好的实践，保证项目按时保质的交付，这才是最重要的。也正是因为项目突然设定的deadline，让我从项目实践中对原来根深蒂固的敏捷流程有了一些更加深刻的认识，那就是：项目中那些不恰当的行为是不可避免的，但是至少我们自己要知道什么地方做的不对。</p>

		
		
	</div>


<div class="meta">
	<div class="date">




Mar 7th, 2017</div>
	<div class="tags">


	<a class='category' href='/blog/categories/agile/'>agile</a>


</div>
	
</div>
</article>


    <article class="post">
	<h2 class="title">
		
		<a href="/blog/2017/03/07/chan-pin-kai-fa-de-liu-da-miu-lun/">
		
			产品开发的六大谬论【译】</a>
	</h2>
	<div class="entry-content">
		<p>Translated by <a href="https://jiamaoweilie.github.io/blog/archives/">Jia Wei</a> &amp; <a href="https://yanyujason.github.io/blog/archives/">Yan Yu</a></p>

<p><a href="https://hbr.org/2012/05/six-myths-of-product-development">原文地址: Six Myths of Product Development</a></p>

<p>大多数产品经理是根据时间和预算启动项目。他们不但没有足够的资源来完成项目，而且还被老板要求有可预测的时间表和交付物。所以，产品经理们会精简团队、要求团队编写较为详细的项目计划，并且要求尽量减少计划变动和时间的浪费。这种方式可能适用于一些低效的工厂来提升效率，但是对于产品开发却有着负面影响。</p>

<p>尽管很多公司对待产品开发与对待制造业的方式相似，但是这两者是截然不同的。在制造实物对象的过程中，任务是重复的，行为活动是可以合理预测的，而且制造的产品每次只会出现在一个地方。而在产品开发中许多任务是独立的，项目需求也会持续改变。而且在某种程度上，由于计算机辅助设计和仿真的广泛使用以及软件与实体产品的结合使用，产品开发的产出物只是信息，这些信息又可以同时出现在不同的地点。</p>

<p>没有认识到这些关键区别导致了很多谬误，破坏了产品开发项目的计划、执行和评估。我们在产品开发方面有着超过50年的学习和咨询经验，也在不同的工业领域（包括半导体、汽车、消费电子、医疗设备、软件和金融服务）看到过这样的谬误，其产生的原因各不相同。在这篇文章中，我们将介绍这些问题，并提供克服这些问题的方法。</p>

<h2>谬论一：资源的高利用率会提升性能。</h2>

<p>在日常的研究和咨询工作中，我们发现大多数公司都竭尽全力使他们在产品开发中的资源得到充分利用。（我们的研究人员Donald在加里弗尼亚理工学院学习管理课程时调研发现一般产品经理对人员的平均利用率会保持在98%以上。）道理似乎很明显：如果一个人不是100%的时间都在工作，那么项目完成时间必然延长。也就是说，工作繁忙的团队的效率会远远高于对人员不能充分利用的团队。</p>

<p>但是在实际工作中，这个逻辑并不能奏效。我们发现，当员工的工作量趋近于饱和时，不管他们的技能多么熟练，产品开发的速度、效率以及产出物的质量都会下降。管理者们低估了高利用率带来的严重负面影响，造成这种现象的主要原因有三个：</p>

<h3>没有充分考虑开发工作的内在可变性。</h3>

<p>产品开发的许多方面是不可预测的，比如：项目何时开始、怎样划分没有依赖的任务，以及那些没有此类工作经验的工人将花费多长时间来完成任务。然而，公司最熟悉的却是那些重复性的工作，比如制造和交易等，它们没有太多需求改变和意外发生。随着资源利用率的提高，产出率也会有相应的线性提升。比如，工作量增加5%，其花费的时间也会多出5%。</p>

<p>具有高可变性的流程却大不相同。随着利用率的提高，延迟也会显著增加（参见《High Utilization Leads to Delays》）。工作量增加5%，其耗费的时间却有可能增加100%。然而，很少会有人理解这种影响。</p>

<blockquote><p><strong>《High Utilization Leads to Delays》：</strong></p>

<p>下图是关于等待队列的数学研究，图中的曲线是应用排队理论计算出来的。它表明在流程可变的条件下，随着项目挂起或者等待时间的延长，资源的利用率会显著增加。尽管图中曲线与项目本身有一定关系，但是当利用率接近100%时，曲线会急剧升高。</p>

<p><div style="text-align:center" markdown="1">
<img src="/images/blogs/high-utilization-leads-to-delays.gif" width = "350" height = "350" />
</div></p></blockquote>

<p>的确，有些变化是由于缺乏规范，而且有些产品开发任务（例如为飞机原型设计组件或者临床实验）具有较多重复工作。但是即使有些工作是可预测的，当它们与一些不可预测的工作相结合时，就会遇到所谓的排队问题。</p>

<h3>不理解排队问题怎样影响经济效益。</h3>

<p>高利用率不可避免的造成项目的排队问题。当部分完成的工作空闲时，等待资源可用，整个项目的持续时间就会增加。队列还会延迟反馈，增加开发人员在错误道路上的探索时间。它们使公司难以适应不断变化的市场需求，难以发现其产品的弱点。严格来讲，这些问题都是管理者们认为的高效率能避免的问题。</p>

<p>即使管理者们知道他们正在创建队列，但是他们很少意识到经济成本。虽然这种成本是可以估算的，但是我们发现大多数公司都不计算这些成本。管理者们需要权衡队列成本和未充分利用产能的成本，以取得适当的平衡。</p>

<p><strong>在产品开发中，在制品库存是完全不可见的。</strong></p>

<p>制造业的队列都是由实体组成，当工厂的存货加倍时，队列是显而易见的。而产品开发不是这样，其库存主要由信息组成，例如设计文档、测试流程及结果、以及构建原型的说明等等。在项目开发过程中如果在制品数量翻倍，团队很难获得物理信号。此外，由于会计准则要求大多数的研发库存值为零，财务报表并不会暴露产品开发过程中库存严重过剩的问题。</p>

<p>不可见或者不可度量的问题是很难解决的。我们以某大型制药厂为例，几年前，新任命的药物研发经理面临着管理难题。和其他大型研发机构的高管一样，他尝试让他的科学家们更具有创新性。他希望科学家们能用更多的新化合物进行实验，以发明更有前途的新型药品，同时尽早淘汰掉没有前途的备用药品。然而，有机体实验是动物实验部门的责任，这个部门是成本中心，不在他的管理范围内。这个部门的考核标准是测试资源利用率，这自然会导致高使用率。造成的结果是药物研发科学家需要花费三到四个月时间来等待那些只需要一周时间就能完成的实验的结果。那些拥有着“良好”管理的测试部门阻碍了研究进程。</p>

<p>显而易见，解决这类问题的方法需要为高可变的进程预留一些缓冲时间。有些公司很早就理解了这一点。几十年来，3M公司为产品开发人员安排了85%的产能。Google公司以“20%时间”而文明，也就是每周允许工程师们有一天时间干自己想做的任何事情，这意味着，如果项目落后于计划，他们也会有额外的时间容量来进行调整。但是，根据我们的经验，这类措施很难实施。正如后面讨论的内容一样，很少有组织能抵制物尽其用的诱惑。一旦有空余时间，管理者们就会安排更多的工作。</p>

<p>万幸，下面还有其他可行的解决方案：</p>

<p><strong>改变管理制度</strong></p>

<p>对于制药公司，他们可以采取措施使得动物测试单元与研究单元的目标一致。例如，公司可以奖励动物测试快速响应（测量时间是从请求到完成实验），而非单纯用资源利用率考核。</p>

<p><strong>选择性增加产量</strong></p>

<p>向利用率为70％或更高的区域增加额外的资源可以显著减少等待时间。如果制药公司将这条理论利用于动物实验，获取化合物反馈的速度将大大提升。在使用计算机进行建模和仿真的实验中，增加产量相对比较简单，只需要购买额外的计算机设备或者软件的许可即可。</p>

<p><strong>限制正在开发的项目数量</strong></p>

<p>如果制药工作不提供动物实验的能力，它仍然可以通过减小正在研究的新化合物实验的数量来降低利用率。严格限制产品开发流程会突出重点项目并且使优先级明确。</p>

<p><strong>使在制品库存可视化</strong></p>

<p>一种方法是使用可视化的控制墙板。这可以采用多种形式，但关键在于需要有某种实体标记来代表开发工作（参见《Typical Work-in-Process Control Board》），例如Post-it笔记。一个控制墙板应该显示各个部门所有正在进行的工作和项目的状态，而且它应该位于整个团队的中心位置。每天早上团队围绕墙板进行15分钟左右的站会以协调进展，保证工作正常进行。</p>

<blockquote><p><strong>《Typical Work-in-Process Control Board》：</strong></p>

<p>控制墙板可以通过展示每项工作的当前状态来可视化那些不可见的工作。在设计墙板的时候，大多数团队会通过限制每个阶段最大任务数量的方式来减少工作延误。下图简单地展示了一个包含6至10人左右的软件项目团队的工作墙板。</p>

<p><div style="text-align:center" markdown="1">
<img src="/images/blogs/typical-work-in-process-control-board.gif" width = "350" height = "350"  />
</div></p></blockquote>

<h2>谬论二：大批量开发能够提高开发过程的经济效益。</h2>

<p>产品开发中产生队列问题的第二个原因是批处理量的大小。假设一个新产品由200个组件组成，可以选择设计和构建所有的200个部件，然后再测试他们。但是如果在开始测试之前仅设计和构建其中的20个部件，那么批处理大小将减小90%。这将对队列等待时间产生巨大的影响，因为在过程中的平均队列处理时间与批处理大小成正比。</p>

<p>减小批处理的大小是精益生产的关键原则。小批量允许制造商削减正在进行的工作数并加速得到反馈，以便减少时间周期，提升产品质量和生产效率。小批量在产品开发中具有更强的适用性，但是很少有开发商可以意识到它的优势。</p>

<p>造成这种现象的一个原因是他们工作流程的特点。因为生产信息大多数对他们是不可见的，批量大小也是如此。另一个原因，开发人员们似乎有一个根深蒂固的偏见，就是使用大批量，因为他们错误的认为大批量能提高产品开发的经济效益。</p>

<p>在好的管理流程中，批量大小将平衡交易和持有成本（参见《How to Determine Optimal Batch Size》）。它类似于在杂货铺买鸡蛋：如果一次买了12个月需要的鸡蛋，那么交易成本会很低，但是大部分鸡蛋都会坏掉，这样会增加持有成本。如果一次只买一天的量，那么损坏会很低，但是交易成本会很高。直觉上，我们需要在这两者之间取得平衡。</p>

<blockquote><p>《How to Determine Optimal Batch Size》:</p>

<p>批处理量大小的改变主要影响两方面的开销：交易成本和持有成本。随着批处理量增大，平均库存量增加，持有成本也就增大。同时，交易成本会减少，因为交易量会减少。</p>

<p>在总开销（包含交易成本和持有成本）最低时，批处理大小的值达到最优。当一个公司的批处理大小的值接近最优值时，小的差异就会有很小的影响。举个例子来说，如果一个公司的批处理大小的值在最优值上下的20%之内，总开销的增加会小于3%。所以即使粗略的预估也会给公司带来很大的经济效益。</p>

<p><div style="text-align:center" markdown="1">
<img src="/images/blogs/how-to-determine-optimal-batch-size.gif" width = "350" height = "350" />
</div></p></blockquote>

<p>了解这种工作方式的公司已经利用IT技术来减少批量大小，通常结果也是惊人的。一些曾经每90天进行一次大批量代码测试的软件公司，现在每天测试一小批量代码。一个使用类似方法测试软件组的电脑设备制造商使得软件测试周期缩短了95%（从48个月减小到2.5个月），效率提高了220%，缺陷率降低了33%，成本也节省了公司预期的2倍。尽管结果只是一个个例，但是我们发现减小批量大小确实能够有效的改善大多数的开发项目。与之类似，计算机仿真和建模工具已经显著减小了产品开发中实验和测试的最佳批量大小。</p>

<blockquote><p>通过减少批处理大小，可以使产品测试效率提升220%并且降低33%的缺陷。</p></blockquote>

<h2>谬论三：我们的开发计划很完美，只需要严格按照计划实施就好。</h2>

<p>在所有的咨询和研究工作中，我们从来没有遇到过任何一个由产品驱动的项目的需求在设计过程中一成不变。但还是有很多团队过度信赖他们制定的开发计划。他们把任何失误都归因于管理和执行不当，为了把风险降到最低，他们会十分小心地踏出每一步，记录一切在项目过程中与阶段性目标相背离的原因。这种思想适合于在完善的生产制造行业中的那些高重复性的工作。然而这种思想为产品创新只会带来不好的结果，因为每天都可能会对产品产生新的认知和见解，而且产品的生态环境也在持续的变化。</p>

<p>一项由美国麻省理工学院的Thomas Allen完成的关于技术问题解决的<a href="http://www.mendeley.com/research/studies-problemsolving-process-engineering-design">研究</a>特别指出了开发工作的不固定性。他发现开发航天设备的工程师们一般都会在确定最佳设计方案之前构思出很多设计提供选择。因为这些方案的性能经常变化，他们会持续测试和优化这些不同的技术解决方案。这种方式在创新项目中十分典型：不断的测试和试验会展示出哪些是可以工作的哪些是不可行的，也会证明最初关于花销和产品价值的假设可能是不成立的。</p>

<p>在产品开发项目的初期明确客户需求也是一件困难的事情。其实仔细想想，也是很有道理的：因为对于客户来说很难精确地说明需求，尤其是在完全没有解决方案的时候。事实上，对已经存在产品特性的熟悉可能会干扰到个人对新产品需求的阐述。客户的偏好或需求也可能在项目开发的末期因为竞争者产品或者新趋势的出现而突然改变。</p>

<p>综合以上原因，无论计划在理论上有多好，有多么出色的执行力，过于坚持原始的计划会后患无穷。这里也不是说项目不需要计划。产品开发是一系列复杂的行为活动，它需要谨慎地合作以及对每个细节的注意。既然如此，计划就应该只被当作关于项目开发最初的假设，需要根据有合理的证据、经济学假设变化和对商机的再评估进行需要持续地改进。（详见哈佛商业评论2007年5月Rita Gunther McGrath和Thomas Keil的著作<a href="https://hbr.org/2007/05/the-value-captors-process-getting-the-most-out-of-your-new-business-ventures">《The Value Captor’s Process》</a>。</p>

<h2>谬论四：项目开始的越早，完成的也会越早。</h2>

<p>之前也提到过，管理者们对闲置时间深恶痛绝。他们更倾向于用启动新项目来消灭任何的闲置时间。即使新的任务因为人员必须返回之前项目而无法完成，管理者们也会辩解说一切新项目中完成的工作在将来做项目时就不需要再做了。这种思想会导致公司启动更多的新项目并超过了所能承受的能力范围，浪费了人力资源。</p>

<p>这种对人力资源的浪费很危险。如果在项目开始之前还没有协调好所有人力资源，那么开发过程就会步履蹒跚。这会是一个大问题，因为产品开发工作是高腐蚀性的：对于技术和市场的假设很快就会过时。项目的进展越慢，项目被重定向的可能性也就越大。确实如此，军方一部门发现项目的花费和完成日期会随着项目的持续时间成指数（四次方）增长。话句话说，当项目的计划时间增加一倍，项目的花费和最终日程会上升到16倍左右。</p>

<p>减少在进行中的项目数量的重要性是很明显的，这里介绍一个经典的排队理论：里特定律。这个定律简单来说就是，生产周期与队列的大小和开发效率的比值成比例。比如，在星巴克店里有20个人在你前面排队，而且咖啡师可以在1分钟内为5名客人服务，你将在4分钟后接受服务。你可以通过提高开发效率或者减少同时进行的作业数来缩短生产周期。在大多数情况下，后者会是实践中的唯一选择。</p>

<p>对于一些产品开发人员而言，在开始工作之前要严格控制开发效率。确保开发人员可以在项目完全结束前都可以按照所需要的速率进行工作；谨慎地管理在进行中的项目的数量；确保一个项目一旦启动，人员配置要在项目结束前都很充足；并且尽力抵御一切将人员从当前项目吸引到新项目的诱惑。</p>

<h2>谬论五：功能越多，就有越多的客户喜欢。</h2>

<p>产品开发团队似乎坚信增加功能可以为客户创造更多的价值，反之就是降低价值。这也解释了为什么产品如此复杂：遥控器似乎不太能用，配置电脑需要数小时，像飞机驾驶舱一样，汽车需要很多开关与旋钮，甚至连不起眼的面包机现在也配备了菜单及LCD显示屏。</p>

<p>挑战“多既是好”这个概念的公司往往制造出的产品简单而有格调，Bang &amp; Olufsen，丹麦有名的电视、电话、音频产品制造商，他们认为客户听音乐时不需要摆弄均衡器和其他控件来调试出最佳的效果，他们的高端扬声器会自动调节以重现最贴近原声的歌曲品质。用户只需要调节音量大小而已。</p>

<p>让公司认可并且实践“少就是多”的理论是非常困难的，因为它需要在产品开发环节中的两个方面进行额外的投入：</p>

<h3>定义问题</h3>

<p>创新过程中最容易被轻视的部分是：辨析哪些问题是开发者们需要解决的。很多公司在这方面投入的时间少之又少，但这个阶段是非常重要的，因为这样团队能够清晰地理解他们的目标、提出假设、通过实验验证和改善假设。高质量的问题描述可以使团队能够关注于真正重要的特性。</p>

<p>在Walt Disney设计迪士尼乐园的时候，相比于其他游乐园，他并没有着急着增加项目的数量（比如游乐设施，食物种类，停车量），而是带着一个很大的问题开始：迪士尼如何为客户提供奇幻的体验？当然，答案并没有随之而来，它需精心详尽的调研，不断的尝试，并且要深入了解对于迪士尼及其客户来说什么是真正意义“奇幻”。IDEO和其他公司都有专属的时间来致力于研究未来的产品或服务。他们的开发人员会学习很多关于市场的知识，观察和采访未来（潜在）客户，研究新产品的竞争力，并且结合一切他们从图片、模型和图表中了解到的信息，最终的作品是深入客户的，因为它们的产品在整个迭代开发过程中被不断的测试、改进或者放弃。</p>

<h3>识别出哪些需要隐藏/删减</h3>

<p>团队经常会倾向于炫耀一些令同事或管理者眼前一亮的技术方案。但作为客户，他们更倾向于用更小的工作量实现产品。从客户的角度出发，最好的解决方案是绕过那些开发者们引以为傲的奇技淫巧，用最简单的方式解决问题。</p>

<p>苹果公司(Apple)深谙其道, 很多方面为人咂舌，比如创新性产品、时尚设计及营销认知等, 但其最大的优势是其定位核心问题的能力。(参考我们四月出版由Walter Isaacson所著的<a href="https://hbr.org/2012/04/the-real-leadership-lessons-of-steve-jobs">《The Real Leadership Lessons of Steve Jobs》</a>。)就像已故的Steve Jobs曾经解释过：“当你遇到问题之初，它看起来很简单，你并没有真正了解问题的复杂度，对应的方案也会非常简单。当你逐渐深入问题，意识到它的复杂性后，你为这些问题逐个拿出复杂的解决方案……这也是大多数人止步之处。” 而苹果公司则不会放弃。 “真正伟大的人会坚持不懈，” Jobs说，“并找到问题的本源，提出完美可行的解决方案。”</p>

<p>确定要删减哪些功能与确定要包含哪些必要的功能是一样重要的，甚至更重要。可惜，一些公司为了试图创新，添加了各种花哨的功能和嘈杂的模板。然而却并没有认真且全面考虑产品本身重要的特性，例如客户价值和使用的灵活性。当这些公司删减一些计划中的功能时，十有八九是因为他们需要降低成本、远远落后预期时间或是因为团队在其他方面失败了。</p>

<blockquote><p>思考哪些功能可以从产品中删掉与思考产品包含哪些功能一样重要。</p></blockquote>

<p>相反，管理者应该集中精力来识别删减计划内的功能是否可以提升产品特性，让团队在可以提高客户体验的事情上集中精力。如何做到这点呢？可以将每个潜在需求当做一个假设，对每个假设在小范围内与潜在客户实验。</p>

<p>开发团队通常认为当他们的产品没有更多功能可以添加时产品就算做完了。或许他们的逻辑应该是相反的：当产品没有可以删除的功能时产品就会接近于完美。就像达芬奇曾说的：“简单是最终极的复杂。”</p>

<h3>谬论六：如果在第一时间做对的事情，我们就会更成功。</h3>

<p>很多产品开发没能满足项目预算、交付周期和技术性能。毋庸置疑，造成这些的原因与粗犷的规划、死板的流程以及不成熟的领导力都有着不可推脱的关系。同时另一个经常被忽略的原因是产品经理会要求团队“第一次就成功”，要求“第一次成功”会导致团队偏向于最低风险的解决方案，即便顾客并不觉得这种解决方案对现有功能有任何改进。更糟糕的是，面对顾客的问题，团队没有被鼓励去发现更具有创新性的解决方案。</p>

<p>为了避免犯错，每个环节团队都会遵循一个线性流程指标（计划，设计，构建，测试，规模，发布），所以大家在回顾过程中会特别关注“门槛”，只有通过“门槛”，才能进入到下一个阶段。当项目进行到下一个阶段，团队会给出标志性的承诺，对于新的洞见的反馈成本也会成数量级上升。后期的成功测试是显著的惊人的，不管多有价值，测试都会被当成挫折。不幸的是，这种线性流程会因为测试反馈的滞后滞后性引起项目超过限度，因为团队在错误的想法中滞留过久，并且问题在被发现的时候，解决它们的成本已经过于昂贵。</p>

<p>只要团队迭代频繁且迅速，并且能够从失败中迅速吸取教训，包容“初次犯错”就将是比较好的策略。那么通过模拟和原型设计技术的优势就会使这种新潮的方式运行起来简单便捷且性价比高。</p>

<blockquote><p><strong>克服常见谬误的可实践指南</strong></p>

<p>1.可视化工作队列和信息</p>

<p>2.量化工作延迟开销并将其作为做决定的一个影响因素</p>

<p>3.在资源利用率高时使资源闲置</p>

<p>4.将管理考核的焦点从效率转为响应时间</p>

<p>5.减少交易成本来减少批处理大小并得到快速反馈</p>

<p>6.尝试更小的批处理大小；即便效果不好，也可以轻松回滚到之前的大小</p>

<p>7.将开发计划当作一种可以在未来发展成可使用的新信息的假设</p>

<p>8.在得到所有许诺和保证时再开始新的项目</p>

<p>9.以简单为目标：思考什么功能可以被删掉，而不仅仅是增加功能</p>

<p>10.在可控制并且是真实的客户环境下尽可能早、迅速、频繁地采用计算机模型和实物原型进行实验</p>

<p>11.强调重叠和迭代——避免线性的流程设计</p>

<p>12.关注快速的反馈而不是第一次的交付的成功</p></blockquote>

<p>我们对<a href="https://hbr.org/product/agile-product-development-managing-development-fle/an/CMR130-PDF-ENG">391个定制集成电路的团队进行过研究</a>，研究发现团队遵循反复迭代并且做到早期频繁测试，在整个过程中产生了更多错误。但是我们使用了低成本的原型技术，所以胜过（在一定的时间和精力的前提下）让团队想尽一切办法一次设计成型的方式。面对高成本原型，团队在规格、开发和验证上花费了很多功夫，是因为他们在项目后期才开始迭代，并且做的很少，所以耽搁了关键问题的发现。</p>

<p>尝试不同的想法对创新项目至关重要，当人们快速频繁的实验，很多新概念将会被舍弃。当然，正因为早期的失败是可取的，所以容许团队快速排除不好的选择，同时专注于更多更有潜力的其他项目。证明汽车设计安全性的碰撞试验、候选药物是否有毒，使客户产生困惑的软件用户界面都是可以避免的可以改进的。如果在项目只敲定了少量资源的初期发现，设计就会比较灵活，并且还可以尝试其他方案。</p>

<blockquote><p>苛求团队做到“第一次就成功”会使团队只选择风险最小的解决方案。</p></blockquote>

<p>一个支持“尽早失败，经常失败”理论的经典例子是新西兰队在1995年的美国杯上的惊人胜利。为了测试改进龙骨设计的想法，新西兰队使用了两条近乎一模一样的船：一条船在项目过程中被逐步修改，另一条作为参照组不做更改。每天，团队在本地的图形工作站上模拟假设的情况，然后把那些看起来很有前途的设想在那条可以修改的船上实践，然后与不做更改的参照物船进行比赛，最后分析结果。相比之下，它的竞争对手Dennis Conner队使用功能更加强大的计算机系统（波音超级计算机），每隔几周进行一次大批量的模拟，然后在一条船上测试可能的解决方案。结果表明：新西兰队完成了更多的学习循环周期，能够更快地消除不理想的结果，最终击败了Dennis Conner队的“Young America”号船。</p>

<p>到目前为止，我们需要明白的是失败的实验结果并不代表着实验的失败，它们产生了改革者无法预见的新信息。实验周期越快，收集到的信息也就越多，也可以将这些信息与具有创新或者存在潜在风险的想法在下一轮实验中实践。在这样的环境中，员工会在工作时间紧张时更容易坚持下去，从事更具挑战的工作，并且超过那些对风险有着保守态度的同伴。</p>

<p>但是创造这种环境也并不容易。哈佛商学院的Amy C. Edmondson在<a href="https://hbr.org/2011/04/strategies-for-learning-from-failure/ar/1">“Strategies for Learning from Failure”</a>（哈佛商业评论，2011年4月）研究过这个问题。失败会导致尴尬并暴露知识的空白，这样会破坏一个人的自尊和在组织中的地位。尽管尽早重新调配珍贵的人力资源对公司来讲有很多好处，但是在项目初期遇到失败后，管理者又能有多高的频率去提拔或者奖励团队呢？这种问题在建立“失败零容忍”或者“零错误”（Six Sigma）机制的组织内尤为明显。</p>

<p>Thomas Alva Edison理解所有的一切。他建立的著名研究快速试验的实验室位于制造模型的机械工厂附近，方便了机械师与研究人员的合作。实验室里有许多藏书，方便快速查询所有需要的信息；实验室附近的储藏室有大量的供给品；而且在实验室里有很多不同种类的工作人员，包括了工匠、科学家和工程师。Edison希望能确保当他或者他的工作人员有任何的想法，在他的实验室中都可以立即实现为可工作的模型或者样品。他提到：“成功真正的衡量标准就是在24小时内就可以着手开始实践的实验个数。”</p>

<p>信息科技的前沿技术，例如计算机辅助设计、建模和仿真，已经使公司在花费更少时间和金钱的前提下开发出更好的产品上迈出了一大步。然而许多公司却还没有发掘出这些工具全部的潜能，因为他们的管理思维并没有像科技那样发展迅速：他们在处理产品开发时的高变化性的信息工作时还是使用了制造业的方法。IT产业的前沿技术还在发展，提升产品开发流程的机会将会更多，然而对于那些还是无法识别产品开发和制造业不同的公司来说，风险也会更大。</p>

		
		
	</div>


<div class="meta">
	<div class="date">




Mar 7th, 2017</div>
	<div class="tags">


	<a class='category' href='/blog/categories/translate/'>translate</a>


</div>
	
</div>
</article>

<nav id="pagenavi">
    
    
    <div class="center"><a href="/blog/archives">Blog Archives</a></div>
</nav>
</div>
	<footer id="footer" class="inner">Copyright &copy; 2017

    Yan Yu

</footer>
	<script src="/javascripts/slash.js"></script>
<script src="/javascripts/jquery.fancybox.pack.js"></script>
<script type="text/javascript">
(function($){
	$('.fancybox').fancybox();
})(jQuery);
</script> <!-- Delete or comment this line to disable Fancybox -->






</body>
</html>