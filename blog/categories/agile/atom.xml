<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Category: agile | YYLFC]]></title>
  <link href="http://yanyujason.github.io/blog/categories/agile/atom.xml" rel="self"/>
  <link href="http://yanyujason.github.io/"/>
  <updated>2017-03-08T21:36:53+08:00</updated>
  <id>http://yanyujason.github.io/</id>
  <author>
    <name><![CDATA[Yan Yu]]></name>
    
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[Offshore项目遇上Deadline]]></title>
    <link href="http://yanyujason.github.io/blog/2017/03/07/offshorexiang-mu-yu-shang-deadline/"/>
    <updated>2017-03-07T22:33:24+08:00</updated>
    <id>http://yanyujason.github.io/blog/2017/03/07/offshorexiang-mu-yu-shang-deadline</id>
    <content type="html"><![CDATA[<p>2013年12月至今，我一直工作在海外交付项目上，经历了大大小小十多个项目，由于ThoughtWorks和我所在项目的客户都很推崇敏捷实践，所以对项目上的敏捷实践也有一点自己的看法。敏捷实践不是的，敏捷那些最基本的实践不是在所有的项目中都实用，它需要根据项目的实际情况进行相应变化，这就需要团队在项目过程中找寻项目的风险和问题，评估这些风险和问题，最终找到解决这些风险和问题的方法。这篇文章就是我自己对近期的一个项目上的实践进行的总结，以及在项目中遇到的具体问题的一些解决方法。</p>

<h2>项目背景</h2>

<p>项目主要是为澳洲某建筑开发商构建一个展示自身信息的网站，主要包括了开发商公司信息、品牌、房屋设计信息、样板间信息以及社交联系方式等，整个项目一共分为两个阶段：第一阶段是构建一个响应式的前端页面用于展示开发商的所有信息，并且只为6个测试开发商上线，用于产品的快速验证和反馈，所以所有数据以JSON格式存放于AWS的S3上，没有后台数据API，前端页面直接消费这6个JSON文件；第二阶段是构建一个管理页面，用于对所有目标开发商提供信息录入功能，包括录入之前提到的所有信息，并将所有信息存入数据库并生成第一阶段所需要的JSON文件，放入S3。最后整个系统与一个现有的管理系统集成起来，加入权限校验，只对开发商类型的用户开放，其他类型的用户无法录入。</p>

<p>项目第一阶段的前端页面成功上线，反馈良好，所以项目第二阶段如期开始。为了更好地实现第二阶段的项目需求，在第一阶段项目结束后，整个项目组（包含客户）进行了一次Project retro，用于发现项目实践中问题并解决，以避免第二阶段重复犯错。一些问题被挖掘出来，比如每个迭代的plan做的不好，每个story的estimation做的不好，由于种种原因没有很好的track起来，很难同时找到BA，QA以及UX一起做showcase，大家也积极讨论解决方案，最终有一些action出来。而且在第二阶段的inception中，全组成员一起了解需求，拆分epic，做estimation，最后提出了系统架构。这套架构方案很好的解决了项目需求：
* 采用前后端分离，前端使用react和redux，因为录入信息都是通过页面表单形式，所有也引入了redux form，前端用于只获取数据渲染页面；后端使用rails-api，提供数据在postgres数据库中的增删改查；在前后端之间又加入了一层backend-for-frontend（并不是传统意义上的BFF），目的是用于前端请求的转发，用户访问权限的校验，以及与第三方服务（比如image server）的集成等。
* 数据录入数据库后，使用AWS的Kinesis和Lambda服务将开发商所有录入信息生成的JSON文件导入S3供第一阶段的前端页面使用。</p>

<p>这是一个看起来很不错的设计，当然，也可以直接选择一套更为直接的ruby on rails解决所有问题。作为一些个稍微有点节操的码农自然不会选择ROR那样子的设计，原因不详述。根据这个设计，我们也作出了estimation，项目7月中旬开始，做完milestone 1的需求，根据现有人员配置（2名PM，1名DL，1名BA，1名QA，1名ops和7名开发，除了其中4名开发外，其余都是客户团队），大约需要到11月中旬。2名PM也很认可，项目就开始了。这套系统看似简单，实际很复杂，有新代码库的构建，有跟其他3个已有系统的集成，也有一些AWS服务的使用。再细节一点，前端代码js、css的打包，前端任务的构建等，一共花费了5名开发人员和1名ops人员2周也就是1个迭代左右的时间完成了codebase，CI pipeline已经AWS相关服务的构建。也就是说在8月初的时候才开始实现Feature，同时，项目组加了2名开发（之前这2名开发在做别的项目）。8月中旬的某一天，DL突然宣布了一个surprise，那就是由于business和sales方面的原定于11月中旬的milestone 1需要提前至10月3日，掐指一算，提前了8周也就是4个迭代。项目突然有了deadline！
对于这个晴天霹雳，作为一个拥有4名成员的专业的服务性团队，我们依据关于cost，time和scope的三角形原则，见图一，给出一般人都会给出的方案，增加cost（加人）和减小scope！
<img src="/images/blogs/quality-triangle.png" alt="" />
（图一：质量三角形原则）</p>

<p>加人就不细说了，只要有budget，可以尽可能多的加人，唯一要考虑的是加什么样的人？往往这种短期的加人对人的要求更高，需要快速了解业务，快速上手代码，不然加人只会拖慢项目进度，因为pair时需要更多的进行业务的讲解和tech基础知识的培训，这是不合适的。下面主要说说scope的问题。</p>

<h2>Deadline下的MVP</h2>

<h3>Story优先级</h3>

<p>在项目交付时间的压力下，自然要对项目的需求进行重新评估。在我们这段时间里，无论是PM还是我们dev本身都参与到了很多关于需求方面的工作。第一项就是排优先级，PM、BA和UX会将所有必须上线的需求从现有的story墙上（因为项目启动时候，epic的划分和epic中的需求大部分已经明确，所以项目开始就建好了所有的卡，至少有一个标题）挪出，排好business上优先级，然后将所有排好的story给所有开发人员和测试人员，开发和测试一起给出每一个story实现的estimation，然后再由PM决定哪些需求要做，哪些需求可以放在后面做。具体的策略如下图：
<img src="/images/blogs/estimation-value.png" alt="" />
（图二：优先级）</p>

<p>先做高业务优先级并且低开发成本的story，再做高业务高开发成本的story，接着是低业务低开发成本的story，最后舍弃掉低业务高开发成本的story。最终BA和DL会根据项目组的velocity给出iteration plan.</p>

<h3>功能优先</h3>

<p>功能优先，顾名思义，就是说优先实现所需要的功能，用户体验在一些特定条件下可以削弱，比如，给内部系统或者给customer的系统的UI体验可以不必像给consumer那么完美。举个项目中的例子，在开发商样板间信息的录入时，给consumer的前端页面会在google map上显示不同样板间的地理位置信息，所以后台信息录入时需要在google map上让customer自定义样板间位置，然而这个在地图上拖拽的需求在业务上至少是milestone 1上没那么重要，转而采用的是经纬度的录入，这样，前端仍然可以给consumer显示合适的位置，但是开发人员在开发时的时间会少很多。在我们的milestone 1中，页面的styling也不需要很完美，我们只需要给customer提供一个readable和usable的表格供他们录入信息就好，至于比如error message的styling，或者页面不同section的背景色区分之类的样式，都省去不做。当然也不是说一点样式没有，如果没有样式，自然无法给用户提供一个可用的网站，比如表格字段的validation error message还是会显示在校验失败字段的上方，只是没有text没有背景色，同时也没有将输入框highlight起来。功能优先的一个负面影响是很少有spike，并不是说不做spike，而是在项目中没有专门的spike卡。当有技术问题或者解决方案不明确时，spike的时间会进入真正story的时间，在estimation时是有所考虑的。也可以像真正在做spike卡一样在story卡里做spike，但是由于story的点数，我们不得不给spike的时间限定一个很小的time box，当有一种或两种解决方案的时候，可能直接就会使用简单或者耗时短的那一种，并没有太多考虑将来的复用性或者功能的可扩展性，一旦将来有新的功能，这种解决方案。而且spike的时间越短，对代码设计或者方案本身的评估来说也就越不准确，很可能因为spike不足，引入其他问题。比如选定的一种react component不能满足新需求新功能的时候，就会需要花费更多的时间去re-implement老功能，再去实现新功能。</p>

<h3>问题——速度优先</h3>

<p>对于开发人员，尤其是在项目交付时间压力比较大的团队里，如何平衡交付速度和技术追求成了一个很难解决的问题。项目工作量很多，开发需要保证项目及时交付，对于开发本身，又需要对代码质量代码追求有最基本的底线和节操。在项目过程中的一次retro里，客户PM和DL明确指出“项目speed first，code quality second”。又由于开发人员自身原因，比如作为vendor，心里难免有vendor心态，就是客户提出来的要求都需要尽量满足，客户说什么就是什么，那就先交付吧，其实并没有按照合作方应有的态势去跟客户争论讨论。
在交付压力下，PM、DL也有压力，比如来自sales团队或者更高一级lead的压力，所以经常在展会上或者IPM上听到DL会问所有人：“我们还有30天，还剩31个story，可以做完吗？”“这个迭代有15张卡，你们做的完吧？”无形之中给团队带来很大精神层面的压力。
一味的追求速度，会给开发人员，尤其会给团队里面的新人养成不好的习惯，比如找齐BA、QA和UX一起showcase可能比较难，或者觉得大家都理解功能是什么，这张卡要做什么，没必要做showcase，又或者因为缺乏对story的kickoff在做卡过程中加入了开发自己对功能的理解，而这些理解并不是PM真正想要的需求。这些坏习惯也会是团队中很大的问题。
在速度优先的思想下，团队遇到了一些问题，也根据团队自己的理解提出了一些改进：</p>

<h4>Story很大</h4>

<p>BA技能的缺失，导致每一个story都很大，这带来的影响是开发人员需要考虑每一个需求的每一种情况，需求多了，难免会漏掉一些。而且对大story的估点也会很不准确，如果估点少了，对开发人员在开发时候的压力会很大。因为有时候开发人员对点数的理解可能有误，觉得每一个点可能就是一天。一个卡比如估了5个点，当做到第3天的时候，发现还有几个需求没有实现，这样会给开发带来很大压力，考虑需求的完整性也会大大下降，进而导致更多的复工和bug。
Story太大怎么办？很明显就会想到——拆卡。好在我们的BA虽然自己写卡的时候不拆，但是她很接受我们自己拆卡，只要有合理的理由。项目中，我们尝试过两种拆卡方式：
* 前后端分离拆卡。我们将一个story的前端和后端工作分开，前端一个卡，后端一张卡。比如我们项目需要录入开发商的每一个设计的信息，表单内容非常多，而且每个信息都有一些validation。我们会拆成前端渲染表单页面，发送获取现有信息、存储新信息的请求，以及页面基本的styling。而后端完成信息增删改查的API和存储校验。这样做的好处是前端能力强的人可以做前端，后端能力强的人做后端，各取所长，提升交付速度。缺点在于提升了沟通和测试成本，前后端的story需要沟通好数据格式。如果前期没有考虑完全，在开发过程中一点点数据格式的变动可能会引起很大的修改。而且有时候前后端分开后的两张卡不是同时做，一对pair定义好的数据格式由于缺少沟通，需要花费下一对pair一些时间去查看（当然可以有些协议测试来保证，但是项目中并没有引入）。而且在前后端做完后，需要有一张独立的卡开做集成，比较耗时。对于测试来说，单纯的后端的卡只能通过一些工具（比如postman）来测试，前端的卡，只能通过浏览器工具看看数据是不是真的发到了后台，对于集成的卡，又需要在连着测试一遍，也很耗时。对于功能交付来说，我们一般都需要保证每一个story传递一定的用户价值。这么做对于没有集成的前端或者后端的卡，只是隐形的交付了一些价值，在集成卡没有上线时，PM因为功能不可用，所以不认为这是交付物。所以，我认为这种拆卡方式只适合于定期发布，也就是完成了很多功能后一次上线。并不适合持续发布，因为后端还好，前端页面发布上去后台功能没有完成是很搞笑的，除非用feature toggle关闭。
* 另一种更拆卡方式是将大story的各个小的功能点拆开。与前后端拆卡不同，这样拆卡可以保证每一个子卡在做完后都是一个可以交付的产物。比如刚才那个例子，对于开发商的设计信息的录入，我们可以拆成上传设计图片，填写设计基本信息，以及添加不同的设计variations；又比如在做这些设计的前端页面filter时，可以拆成按照面积过滤、按照层数过滤，按照卧室数量过滤等，每一个子卡都可以在做完后独立发布。这样做的缺点是有时候一些相似的功能点在并行开发时，会产生一些重复代码。比如我们项目前端用的是react，在面积过滤和卧室数量过滤时的两个component其实可以复用，如果一起开发，不同的开发人员可能会写出不同的component，需要在后面花时间重构，这会增加开发时间。另一个问题是如果拆分的不合理，会使卡产生依赖，就是说A卡必须在B卡结束后才能开始开发。但是如果合理做卡的plan，这个问题就不是一个大问题。</p>

<p>项目上因为story太大，走过很多弯路，也浪费了很多开发和沟通时间，但是慢慢通过自己的拆卡，达到了一个让所有人都接受的程度。解决这个问题我的看法是，当通过拆卡保证这些大的story不会成为影响交付速度和交付质量的blocker时，就算做的不错。</p>

<h4>Estimation</h4>

<p>这是一个大家都熟悉的话题，我想所有接触敏捷的人都已经理解了estimation的意义和做法。但是我想要说的是敏捷里的estimation的概念有时候在外部条件影响下，可能不能够被完美的执行。最主要的问题是——耗时。7个开发，4-5对的pair，对一个自身技能并不出色的BA来说，是很大挑战，所以经常会发现story的需求很不明确，story的划分也很不明确。如果按部就班的做estimation，就会有很多assumption，基于这些假设做出来的estimation最大的缺陷就是当需求明确后，并且实际需求跟你的assumption又不是完全匹配，estimation肯定是需要re-work的。又需要召集所有dev，重新花时间做estimation。如果需求变更比较大，那些re-work的estimation可能在实际开发过程中没有了意义。再加上即使我们对每一个卡做了estimation，它也只是一个数字，DL还是使用story数量来计算velocity，这更让estimation显得没有意义。
所以我们决定改变传统意义上的estimation，我们加入了confidence level。在对每一个卡进行了技术估点之后，我们又加入了对这个卡的信心估点，也就是说每个人要根据自己的技术能力和对需求的理解程度对每一个卡加入confidence的估点。如果这个卡给我做，我十分确认技术解决方案？还是我只知道可能的方案？或者我没有相关的经验？甚至是我完全不理解需求？每个卡也只花费很短的时间。这带来的好处是帮助了DL更好地做plan，而且在做卡的时候，根据这个confidence level可以提早的进行讨论或者寻求帮助，对进度有促进左右。
对于频繁的需求变更，我们的实践是：在开发之前的变更，只需要更新story就好。在开发过程中的需求变更（在我们项目中经常发生，因为有些需求真的是开发在做的过程中驱动出来的），开发需要及时改正，因为如果按照原来的需求做完，PM又想要新的需求，可能做之前需求的时间就浪费了。在测试时候或者Customer Acceptance时候的需求变更，我们会重新建新卡完成，而不是打回给开发继续开发。这可能是其他项目的标准做法，但是在我们项目中实践的并不好，起初任何需求变更都会放在同一张卡中，反复去做（我经历过3次需求A变更到B再变更回A的过程）。这样做会导致整个story在in dev的时间很长，而且很影响story的life cycle time。间接的影响是PM觉得我们这么一个功能做了很长时间，因为PM不会了解所有卡的实现细节，也不会记得每一张卡的需求变更，结果导向来看，确实花了很长时间，而且有些迭代真的只交付了很少卡。采用之前提到的方法，可以保证卡按照正常流程交付，避免了开发被PM的误解，也会增加PM对开发的信心。</p>

<h4>Tech debt</h4>

<p>在日常完成story过程中，如果发现有任何技术改进点，如果代码改动比较大，耗时比较长，我们会写成一个tech debt的卡，在项目交付后再做。在创建这些卡后，会给出estimation，也会给出做了这个改动，带来的影响是什么，比如会提升代码可读性，节约今后的维护或者扩展成本，还是只是这样子修改单纯为了代码炫酷。每一张卡都会平衡这些影响。举个redux form从version 5到6的升级，具体好处不详述，这个升级需要很大改动，它可以保证新的redux form的代码更加可读，也修复了一些本身功能性的不足，但是这一次的修改会引起很大的修改，因为一些component或者form的field的用法有很大改变，所以需要整体性的评估再决定要不要做。
这些“技术债”肯定对当前或者将来有影响，但是要不要还，什么时间还，需要评估来决定。</p>

<h4>Dev huddle</h4>

<p>这是一个被全组都认可的实践。每天项目所有人有standup，用于更新每张卡的进度，这更关注与业务方面的更新，由于时间原因，又不能太深的讨论技术细节，所以我们所有的开发和测试也有自己的standup，用来专门讨论正在开发的story的解决方案或者遇到问题，也可以是更新引入了什么新的技术，比如一些gem之类的，我们称这个活动为“dev huddle”。期初，我并不认可这个活动，因为让所有开发（项目组有7名开发）每天在一起半个小时讨论每个卡是怎么做的本身的成本就很大，而且给我在心里的感觉是我很平常的story的解决方案都需要其他5名开发的认可，或者叫“审阅”，我才可以继续做，折让我的心里觉得每个人是不是都不是很信任团队其他成员。但是经过一段时间后，我改变了这种看法。在dev huddle上，我们讨论了如何设计API，如何设计数据库结构，如何正确使用redux form和一些具体问题的解决方案，有时候也会show一下未完成的code，这样让所有人都对我们的代码库有了很深的了解，知道每个人都在做什么，大概是怎么做的，所以在做story卡的时候可以完全按照优先级来拿卡，不用太考虑我在这个代码库或者我对这个方面的代码逻辑不熟悉。这无形中其实减少了一些卡的block，潜在的提升了速度。而且每个story的解决方案都是被全组认可的，每个人都可以发表自己的意见，都可以把自己在某方面的知识分享给大家，这保证了大家都在高交付压力下也能学到东西并且交付质量也是过关的。</p>

<h4>测试驱动开发（TDD）？</h4>

<p>关于要不要TDD，在项目过程中争议很大。后台API端的TDD还好说，可以比较清楚也比较简单的进行TDD。可是前端react component的测试，由于一些原因，比如开发对react的单元测试不熟悉，测试的力度如何，什么要测，什么不测，这些都是阻碍前端TDD的障碍。而且，就TDD本身来说，因为每个人对TDD的理解深入程度不同，熟练程度不同，认可度不同，所以强制要求TDD或者短期内深入了解TDD，尤其是前端，在短期有Deadline的项目里看起来并不是很适合。所以，我们达成一致，前端可以先写实现再加入测试，但是要保证测试覆盖率达到标准。</p>

<h3>管理客户期望</h3>

<p>管理客户期望？在我看来，客户都是贪婪的，如果你的团队在一个迭代能完成20个点，客户在一个迭代中排了比20个点稍微多一点的stories，比如23个点，这时，团队看了这23个点，觉得必须给客户完成，所以采用一些“未告知客户”的加班，或者放弃一些好的代码实践，或者放弃了一些公司的session学习等，最终完成了23个点，这时团队暴露的velocity会因为工作时间加长而增加，这时“贪婪的”客户势必会给每个迭代排更多的点，更多的卡，而一次次团队做出“牺牲”最终都达到了客户“贪婪的”期望，客户会更加“贪婪”，直到团队达到极限。这对于团队来说是很危险的，尤其是像我们这种客户很不善鼓励的团队而言。在项目进行到中期，大概9月份的样子，因为整个团队都很压抑，似乎每一个迭代都完成了客户“贪婪的”期望后，还是在被反复询问“我们在10月3号之前可以做完吗？这个迭代plan的卡可以做完吗？”诸如此类很不专业的问题。事实上这个问题对于开发很难回答，尤其是连自己velocity和迭代estimation做的很不好的团队，大家都选择沉默（这是不好的），所以客户会觉得你们不提反对意见，那么就是可以完成了。组里中间有一个其他组过来帮忙的开发人员在工作了两周后，发表感慨：“你们每天工作时间好长，感觉早上下午只有一次站起来去喝水的机会。”这是也不是一个好的实践。所以，如何管理客户期望，成了主要问题。当时有个其他的同事给我们建议：“下一次客户再plan太多story点或者个数的时候，你们故意不要完成，这样团队压力就不会太大了。”我们觉得这并不是一个从根本解决问题的方案。于是我们团队做了内部retro，发现最主要的问题还是estimation和velocity计算方式的问题。之前我们给每一张卡的估点采用T-shirt size的方式，只有S，M和L三种，DL计算velocity的方式更是采用了数story个数的方式。然而组内BA的能力并没有达到可以把每一个story拆的一样大小。这样就导致客户DL对团队velocity理解有着很大的偏差，所以在做plan的时候也不准确。我们团队在尝试3、4次给客户DL提出要用fibonacci数列方式估点，用点数计算velocity后，客户终于同意，并且在每个迭代里面只plan跟velocity相同点数的story。前面两次我们都只是提出了我们应该怎么做，这么做的好处是什么这样的理论，但是并没有将真实的数据反应给客户，比如我们自己并没有采用fibonacci数列真正给每个story，直到我们自身实践，客户也真的看到了这样做的好处，所以最后一次他也做出了改变。其实在这里，我并不是想说如何以正确的方式去做estimation和计算velocity，我想强调的是在给客户提出任何建议的时候，最好有数据支持，并且需要从自身团队做起，把好的实践应用到项目里，通过这些时间潜移默化的促进项目进展，也慢慢的影响客户的工作方式，这才是应该做的，而不是整天抱怨项目压力大，客户难搞。</p>

<h2>小结</h2>

<p>这些就是我们项目上遇到的一些问题和我们为了解决这些问题的一些实践。总结一下就是，项目进行过程中，一些有悖于敏捷实践best practice的问题肯定都会存在，我们要做的并不是将敏捷那些最基本的流程和概念强行加入到自己的项目中，我们所要做的是将那些好的理论转化成为最适合自己项目的好的实践，保证项目按时保质的交付，这才是最重要的。也正是因为项目突然设定的deadline，让我从项目实践中对原来根深蒂固的敏捷流程有了一些更加深刻的认识，那就是：项目中那些不恰当的行为是不可避免的，但是至少我们自己要知道什么地方做的不对。</p>
]]></content>
  </entry>
  
</feed>
